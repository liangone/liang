{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{356:function(t,a,s){\"use strict\";s.r(a);var n=s(12),r=Object(n.a)({},(function(){var t=this,a=t._self._c;return a(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":t.$parent.slotKey}},[a(\"h1\",{attrs:{id:\"_17-说说你对分而治之、动态规划的理解-区别\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_17-说说你对分而治之、动态规划的理解-区别\"}},[t._v(\"#\")]),t._v(\" 17.说说你对分而治之、动态规划的理解？区别？\")]),t._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:\"https://cdn.jsdelivr.net/gh/IceRain-mvc/cdn/img/image-20211015084616085.png\",alt:\"image-20211015084616085\"}})]),t._v(\" \"),a(\"h2\",{attrs:{id:\"一、分而治之\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#一、分而治之\"}},[t._v(\"#\")]),t._v(\" 一、分而治之\")]),t._v(\" \"),a(\"p\",[t._v(\"分而治之是算法设计中的一种方法，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并\")]),t._v(\" \"),a(\"p\",[t._v(\"关于分而治之的实现，都会经历三个步骤：\")]),t._v(\" \"),a(\"ul\",[a(\"li\",[t._v(\"分解：将原问题分解为若干个规模较小，相对独立，与原问题形式相同的子问题\")]),t._v(\" \"),a(\"li\",[t._v(\"解决：若子问题规模较小且易于解决时，则直接解。否则，递归地解决各子问题\")]),t._v(\" \"),a(\"li\",[t._v(\"合并：将各子问题的解合并为原问题的解\")])]),t._v(\" \"),a(\"p\",[t._v(\"实际上，关于分而治之的思想，我们在前面已经使用，例如归并排序的实现，同样经历了实现分而治之的三个步骤：\")]),t._v(\" \"),a(\"ul\",[a(\"li\",[t._v(\"分解：把数组从中间一分为二\")]),t._v(\" \"),a(\"li\",[t._v(\"解决：递归地对两个子数组进行归并排序\")]),t._v(\" \"),a(\"li\",[t._v(\"合并：将两个字数组合并称有序数组\")])]),t._v(\" \"),a(\"p\",[t._v(\"同样关于快速排序的实现，亦如此：\")]),t._v(\" \"),a(\"ul\",[a(\"li\",[t._v(\"分：选基准，按基准把数组分成两个字数组\")]),t._v(\" \"),a(\"li\",[t._v(\"解：递归地对两个字数组进行快速排序\")]),t._v(\" \"),a(\"li\",[t._v(\"合：对两个字数组进行合并\")])]),t._v(\" \"),a(\"p\",[t._v(\"同样二分搜索也能使用分而治之的思想去实现，代码如下：\")]),t._v(\" \"),a(\"div\",{staticClass:\"language-js extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-js\"}},[a(\"code\",[a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"function\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token function\"}},[t._v(\"binarySearch\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),a(\"span\",{pre:!0,attrs:{class:\"token parameter\"}},[t._v(\"arr\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\",\")]),t._v(\"l\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\",\")]),t._v(\"r\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\",\")]),t._v(\"target\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"{\")]),t._v(\"\\n    \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"if\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),t._v(\"l\"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\">\")]),t._v(\" r\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"{\")]),t._v(\"\\n        \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"return\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"-\")]),a(\"span\",{pre:!0,attrs:{class:\"token number\"}},[t._v(\"1\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n    \"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"}\")]),t._v(\"\\n    \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"let\")]),t._v(\" mid \"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"=\")]),t._v(\" l \"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"+\")]),t._v(\" Math\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\".\")]),a(\"span\",{pre:!0,attrs:{class:\"token function\"}},[t._v(\"floor\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),t._v(\"r\"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"-\")]),t._v(\"l\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"/\")]),a(\"span\",{pre:!0,attrs:{class:\"token number\"}},[t._v(\"2\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),t._v(\"\\n    \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"if\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),t._v(\"arr\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"[\")]),t._v(\"mid\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"]\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"===\")]),t._v(\" target\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"{\")]),t._v(\"\\n        \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"return\")]),t._v(\" mid\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n    \"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"}\")]),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"else\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"if\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),t._v(\"arr\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"[\")]),t._v(\"mid\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"]\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"<\")]),t._v(\" target \"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"{\")]),t._v(\"\\n        \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"return\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token function\"}},[t._v(\"binarySearch\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),t._v(\"arr\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\",\")]),t._v(\"mid \"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"+\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token number\"}},[t._v(\"1\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\",\")]),t._v(\"r\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\",\")]),t._v(\"target\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),t._v(\"\\n    \"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"}\")]),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"else\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"{\")]),t._v(\"\\n        \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"return\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token function\"}},[t._v(\"binarySearch\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),t._v(\"arr\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\",\")]),t._v(\"l\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\",\")]),t._v(\"mid \"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"-\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token number\"}},[t._v(\"1\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\",\")]),t._v(\"target\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),t._v(\"\\n    \"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"}\")]),t._v(\"\\n\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"}\")]),t._v(\"\\n\")])])]),a(\"h2\",{attrs:{id:\"二、动态规划\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#二、动态规划\"}},[t._v(\"#\")]),t._v(\" 二、动态规划\")]),t._v(\" \"),a(\"p\",[t._v(\"动态规划，同样是算法设计中的一种方法，是一种在数学、管理科学、计算机科学、经济学和生物信息学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法\")]),t._v(\" \"),a(\"p\",[t._v(\"常常适用于有重叠子问题和最优子结构性质的问题\")]),t._v(\" \"),a(\"p\",[t._v(\"简单来说，动态规划其实就是，给定一个问题，我们把它拆成一个个子问题，直到子问题可以直接解决\")]),t._v(\" \"),a(\"p\",[t._v(\"然后呢，把子问题答案保存起来，以减少重复计算。再根据子问题答案反推，得出原问题解的一种方法。\")]),t._v(\" \"),a(\"p\",[t._v(\"一般这些子问题很相似，可以通过函数关系式递推出来，例如斐波那契数列，我们可以得到公式：当 n 大于 2的时候，\"),a(\"code\",[t._v(\"F(n) = F(n-1) + F(n-2)\")]),t._v(\" ，\")]),t._v(\" \"),a(\"p\",[a(\"code\",[t._v(\"f(10)= f(9)+f(8),f(9) = f(8) + f(7)\")]),t._v(\"...是重叠子问题，当\"),a(\"code\",[t._v(\"n = 1、2\")]),t._v(\"的时候，对应的值为2，这时候就通过可以使用一个数组记录每一步计算的结果，以此类推，减少不必要的重复计算\")]),t._v(\" \"),a(\"h3\",{attrs:{id:\"适用场景\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#适用场景\"}},[t._v(\"#\")]),t._v(\" 适用场景\")]),t._v(\" \"),a(\"p\",[t._v(\"如果一个问题，可以把所有可能的答案穷举出来，并且穷举出来后，发现存在重叠子问题，就可以考虑使用动态规划\")]),t._v(\" \"),a(\"p\",[t._v(\"比如一些求最值的场景，如最长递增子序列、最小编辑距离、背包问题、凑零钱问题等等，都是动态规划的经典应用场景\")]),t._v(\" \"),a(\"p\",[t._v(\"关于动态规划题目解决的步骤，一般如下：\")]),t._v(\" \"),a(\"ul\",[a(\"li\",[t._v(\"描述最优解的结构\")]),t._v(\" \"),a(\"li\",[t._v(\"递归定义最优解的值\")]),t._v(\" \"),a(\"li\",[t._v(\"按自底向上的方式计算最优解的值\")]),t._v(\" \"),a(\"li\",[t._v(\"由计算出的结果构造一个最优解\")])]),t._v(\" \"),a(\"h2\",{attrs:{id:\"三、区别\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#三、区别\"}},[t._v(\"#\")]),t._v(\" 三、区别\")]),t._v(\" \"),a(\"p\",[t._v(\"动态规划算法与分治法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解\")]),t._v(\" \"),a(\"p\",[t._v(\"与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往「不是互相独立」的，而分而治之的子问题是相互独立的\")]),t._v(\" \"),a(\"p\",[t._v(\"若用分治法来解这类问题，则分解得到的子问题数目太多，有些子问题被重复计算了很多次\")]),t._v(\" \"),a(\"p\",[t._v(\"如果我们能够保存已解决的子问题的答案，而在需要时再找出已求得的答案，这样就可以避免大量的重复计算，节省时间\")]),t._v(\" \"),a(\"p\",[t._v(\"综上，可得：\")]),t._v(\" \"),a(\"ul\",[a(\"li\",[t._v(\"动态规划：有最优子结构和重叠子问题\")]),t._v(\" \"),a(\"li\",[t._v(\"分而治之：各子问题独立\")])])])}),[],!1,null,null,null);a.default=r.exports}}]);","extractedComments":[]}